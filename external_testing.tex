% A draft document providing some external tests. This should be done before  you have a meeting in week 49.

Tests for the letter parser. Tries to parse every character in the alphabet in order and makes sure the expected character is parsed.
Also makes sure non-letter characters cause the parser to fail.
\begin{python}
def test_letter(self):
    parser = letter()
    for c in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz":
        self.assertEqual(parser.parse(c), c)
    for c in "0123456789+-.,;:?^*":
        self.assertRaises(ParseError, parser.parse, c)

    self.assertEqual(parser.parse("xyz1"), "x") # yz1 remains to be consumed
    self.assertRaises(ParseError, parser.parse, "42")
\end{python}


Tests for the times parser. The parser is suposed to run a given parser atleast $n$ times, and at most $m$ times. Here we test it using the string parser with various strings and $n$/$m$ values.
\begin{python}
def test_times(self):
    parser = times(string("x"), 3, 5)
    self.assertRaises(ParseError, parser.parse, "")
    self.assertRaises(ParseError, parser.parse, "x")
    self.assertRaises(ParseError, parser.parse, "xx")
    self.assertEqual(parser.parse("xxx"), ["x"]*3)
    self.assertEqual(parser.parse("xxxx"), ["x"]*4)
    self.assertEqual(parser.parse("xxxxx"), ["x"]*5)
    self.assertEqual(parser.parse("xxxxxx"), ["x"]*5) # one x remains to be consumed
    self.assertRaises(ParseError, parser.parse_strict, "xxxxxx")
    self.assertRaises(ParseError, parser.parse_strict, "xxxxxxx")
    self.assertRaises(ParseError, parser.parse_strict, "xxxxxxxxxxxxxxxx")
\end{python}


Tests for the join parser. This parser takes two parsers $A$ and $B$, it runs $A$ on the input, then $B$. First we try a very trivial case where we first try to parse the string 'x' and then the string 'y' and make sure that they both get parsed. Next we want to try that if parser $A$ fails, then parser $B$ should not run. This is done by creating a global variable and setting it to false, then we set parser $B$ to be a parser that changes the value of the global to the variable to true, then it parses the string. The test makes sure that parser $A$ fails and that the global variable is unchanged.
\begin{python}
def test_joint(self):
    parser = string('x') + string('y')
    self.assertEqual(parser.parse('xy'), ('x', 'y'))
    self.assertRaises(ParseError, parser.parse, 'y')
    self.assertRaises(ParseError, parser.parse, 'z')

    nonlocals = {'changed': False}

    @generate
    def fn():
        nonlocals['changed'] = True
        yield string('y')

    parser = string('x') + fn
    self.assertRaises(ParseError, parser.parse, '1')
    self.assertEqual(nonlocals['changed'], False)
\end{python}



% \section{External listing highlighting}

% \pythonexternal{sample.py}

% \section{Inline highlighting}

% Definition \pythoninline{class MyClass} means \dots
